# ALU

w位的无符号乘法结果的低w位，就是补码乘法有符号表示，这个在CSAPP中有证明

本质上乘法就是把被乘数的倍数相加，每个倍数如果超过了w范围也看成是补码加法的自然溢出，没有影响。

所以乘法器的低w位结果是`mul0`和`mulu0`(因为相等所以未专门列出)，高位是`mulhu0`。

现在的问题是，怎么把无符号乘法的高w位，转换为有符号的表示，比如w=4



```c
1101 x 0101 = 0100 0001
13   x  5   = 64 + 1
-3   x  5   = -15  -> 1111 0001

这个例子中，mulh应该是1111，而不是0100


1101 x 0111 = 0101 1011
13   x  7   = 80 + 11
-3   x  7   = -21  -> 1110 1011

这个例子中，mulh应该是1110，而不是0101


1111 x 1111 = 1110 0001
15 x 15 = 224 + 1
-1 x -1 = 1
这个例子中，mulh应该是0000，而不是1110
```

这个过程也就是`i8(c) = (i4)a * (i4)b`，所以先用符号拓展，把a、b变为有符号的8位表示，然后再相乘，那么低8位自然就是有符号数了。但是因为每个寄存器只能存4位，所以乘法要分部做，然后把三个部分相加，效率有点低。



# CPU

## ImmSel & ImmGen
如下表所示，`b0=b1=1`未列出，主要想法是用t4~t6直接作为ImmSel，所以制订一个策略，如果t2为1，t4~t6则加1，如果t3为1，t4~t6则-1，当作`T5`，然后到ImmGen中按照类别接线
```
I T0 & T1 & T7
0x03  0000 00
0x13  0001 00
0x67  0110 01

R T3
0x33  0011 00

S T2
0x23  0010 00

B T6
0x63  0110 00

U T4
0x37  0011 01

J T5
0x6f  0110 11

```


## RegWEn 

是否开启RegFile的写入，只有B-Type、S-Type的指令需要置为0，其余都是1

观察命令表，`t5=1`排除I中的0x03和0x13，`t4=0`排除UR，最后`t2=0`排除I中0x67和J，构造`(t5 * t4^ * t2^)^`可以满足，即`t5^ + t4 + t2`


## MemRW

是否开启内存的写入，只有S-Type才需要开启，也就是t6~t4为`010`时

## WBSel

选择写回的内容

```
I 对应Mem output T1
0x03  0000 00

Jump 对应PC+4 T2
0x6f  0110 11
0x67  0110 01

其余对应ALU output T0
```

`t6=1 and t5=1 and t2=1`筛选出PC+4 0x6f和0x67  
`t6=0 and t5=0 and t4=0`筛选出Mem 0x03

再利用Mux选择出常量，注意上面两个筛选信号一定是互斥的。
