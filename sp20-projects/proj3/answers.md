# ALU

w位的无符号乘法结果的低w位，就是补码乘法有符号表示，这个在CSAPP中有证明

本质上乘法就是把被乘数的倍数相加，每个倍数如果超过了w范围也看成是补码加法的自然溢出，没有影响。

所以乘法器的低w位结果是`mul0`和`mulu0`(因为相等所以未专门列出)，高位是`mulhu0`。

现在的问题是，怎么把无符号乘法的高w位，转换为有符号的表示，比如w=4



```c
1101 x 0101 = 0100 0001
13   x  5   = 64 + 1
-3   x  5   = -15  -> 1111 0001

这个例子中，mulh应该是1111，而不是0100


1101 x 0111 = 0101 1011
13   x  7   = 80 + 11
-3   x  7   = -21  -> 1110 1011

这个例子中，mulh应该是1110，而不是0101


1111 x 1111 = 1110 0001
15 x 15 = 224 + 1
-1 x -1 = 1
这个例子中，mulh应该是0000，而不是1110
```

这个过程也就是`(i8)c = (i4)a * (i4)b`，所以先用符号拓展，把a、b变为有符号的8位表示，然后再相乘，那么低8位自然就是有符号数了。但是因为每个寄存器只能存4位，所以乘法要分部做，然后把三个部分相加，效率有点低。



# CPU

## ImmSel & ImmGen
如下表所示，`b0=b1=1`未列出，主要想法是用t4~t6直接作为ImmSel，所以制订一个策略，如果t2为1，t4~t6则加1，当作`T7`或`T4`，如果t3为1，t4~t6则-1，当作`T5`，然后到ImmGen中按照类别接线
```
I T0 & T1 & T7
0x03  0000 00
0x13  0001 00
0x67  0110 01

R T3
0x33  0011 00

S T2
0x23  0010 00

B T6
0x63  0110 00

U T4
0x37  0011 01

J T5
0x6f  0110 11

```


## RegWEn 

是否开启RegFile的写入，只有B-Type、S-Type的指令需要置为0，其余都是1

观察命令表，`t5=1`排除I中的0x03和0x13，`t4=0`排除UR，最后`t2=0`排除I中0x67和J，构造`~(t5 * ~t4 * ~t2)`可以满足，即`~t5 + t4 + t2`


## MemRW

是否开启内存的写入，只有S-Type才需要开启，也就是t6~t4为`010`时

## WBSel

选择写回的内容

```
I 对应Mem output T1
0x03  0000 00

Jump 对应PC+4 T2
0x6f  0110 11
0x67  0110 01

其余对应ALU output T0
```

`t6=1 and t5=1 and t2=1`筛选出PC+4 0x6f和0x67  
`t6=0 and t5=0 and t4=0`筛选出Mem 0x03

再利用Mux选择出常量，注意上面两个筛选信号一定是互斥的。


## ASel

从`rs1`和`pc`中选择ALU的第一个操作数

只有B-Type(0x63)和J-Type(0x6f)会选择`pc`，为了和0x67区分，需要`t6=1 and t5=1 and ~(t3 xnor t2)`

## BSel

从`rs2`和`imm`中选择ALU的第二个操作数

只有R-Type(0x33)会选择`rs2`，其余情况都会选择`imm`，为了和0x37区分，需要`t5=1 and t4=1 and t2=0`


## BrUn

要求使用无符号比较时置为1，即B-Type并且func3为6


## PCSel

两个jump命令J-Type(0x6f)、I-Type(0x67)无条件为PC设置新的值，可以复用WBSel中的接线

B-type中的4中情况，分条件设置PC新的值

> 哎，做到现在，感觉还不如一开始就直接把用与门把每个opcode、func3、funct7类别直接筛选，简化干啥呀，还不好懂，通用为先


## ALUSel

基础运算是加法，特殊的是R-Type I-Type U-Type中的一些运算，把他们单独拆出来。


R-Type

opcode | f3 | f7[5\|0] | ALUSel | ALUSel BIN |cmd 
-- | -- | -- | -- | -- | -- |
0x33| 0 | 01 | 10 | 1010  | mul
0x33| 0 | 10 | 12 | 1100  | sub
0x33| 1 | 00 | 6  | 0110  | sll
0x33| 1 | 01 | 14 | 1110  | mulh
0x33| 2 | 00 | 7  | 0111  | slt
0x33| 3 | 01 | 11 | 1011  | mulhu
0x33| 4 | 00 | 3  | 0011  | xor
0x33| 5 | 00 | 4  | 0100  | srl
0x33| 5 | 01 | 8  | 1000  | divu
0x33| 5 | 10 | 5  | 0101  | sra
0x33| 6 | 00 | 2  | 0010  | or
0x33| 7 | 00 | 1  | 0001  | and
0x33| 7 | 01 | 9  | 1001  | remu

按照Sel排序，emm……这f3有什么规律吗
opcode | f3 | f7[5\|0] | ALUSel | ALUSel BIN |cmd 
-- | -- | -- | -- | -- | -- |
0x33| 7 | 00 | 1  | 0001  | and
0x33| 6 | 00 | 2  | 0010  | or
0x33| 4 | 00 | 3  | 0011  | xor
0x33| 5 | 00 | 4  | 0100  | srl
0x33| 5 | 10 | 5  | 0101  | sra
0x33| 1 | 00 | 6  | 0110  | sll
0x33| 2 | 00 | 7  | 0111  | slt
0x33| 5 | 01 | 8  | 1000  | divu
0x33| 7 | 01 | 9  | 1001  | remu
0x33| 0 | 01 | 10 | 1010  | mul
0x33| 3 | 01 | 11 | 1011  | mulhu
0x33| 0 | 10 | 12 | 1100  | sub
0x33| 1 | 01 | 14 | 1110  | mulh



U-Type

opcode | f3 | f7[5\|0] | ALUSel | ALUSel BIN |cmd 
-- | -- | -- | -- | -- | -- |
0x23| * | * | 13 | 1101  | bsel


I-Type

slli、srli、srai中的f7仍然有值，因为位移只会用到低5位，所以用f7来进一步区分。但是slli的f7限制感觉没有必要吧，靠0x13和f3就足够定位了。这一部分的AlUSel输出和R-Type是一样的

opcode | f3 | f7[5\|0] | ALUSel | ALUSel BIN | cmd 
-- | -- | -- | -- | -- | -- |
0x13| 1 | 00 | 6  | 0110  | slli
0x13| 2 | * | 7  | 0111  | slti
0x13| 4 | * | 3  | 0011  | xori
0x13| 5 | 00 | 4  | 0100  | srli
0x13| 5 | 10 | 5  | 0101  | srai
0x13| 6 | * | 2  | 0010  | ori
0x13| 7 | * | 1  | 0001  | andi


我的想法是，通过综合f3、f7的信息，形成一个4位的选择码，然后通过排列Mux选项，输出对应的类别。
